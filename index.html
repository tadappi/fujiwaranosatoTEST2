<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>20autorota — three.js viewer (Troika Text版)</title>
  <style>
    html,body{height:100%;margin:0}
    #app{position:fixed;inset:0;background:#c2c2c2}
    canvas{display:block}
    .hint{
      position:fixed;left:10px;bottom:10px;color:#cfd8dc;
      font:12px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      opacity:.85;user-select:none;background:rgba(0,0,0,.35);
      padding:6px 8px;border-radius:6px
    }
  </style>

  <!-- === importmap: three / troika 系 === -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
      "troika-three-text": "https://unpkg.com/troika-three-text@0.49.1/dist/troika-three-text.esm.js",
      "troika-three-utils": "https://unpkg.com/troika-three-utils@0.49.1/dist/troika-three-utils.esm.js",
      "troika-worker-utils": "https://unpkg.com/troika-worker-utils@0.49.1/dist/troika-worker-utils.esm.js"
    }
  }
  </script>
</head>

<body>
<div id="app"></div>
<div class="hint">左:回転 中:パン ホイール:ズーム｜ピン/エリアはホバーで反応・クリックでリンク（寄ってから即切替）</div>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'https://unpkg.com/three@0.165.0/examples/jsm/controls/OrbitControls.js';
  import { GLTFLoader } from 'https://unpkg.com/three@0.165.0/examples/jsm/loaders/GLTFLoader.js';
  import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';
  import { Text } from 'troika-three-text';

  // ========================= 基本設定 =========================
  const DEFAULT_BG = '#c2c2c2';
  const FONT_URL = 'https://fonts.gstatic.com/s/notosansjp/v52/-F63fjptAgt5VM-kVkqdyU8n3kwq0nB4.woff'; // 日本語OK

  const container = document.getElementById('app');
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(DEFAULT_BG);

  const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 5000);
  camera.position.set(0, 40, 80);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.autoRotate = true;
  controls.autoRotateSpeed = 0.5;

  const ambient = new THREE.AmbientLight(0xffffff, 1.0);
  const sun = new THREE.DirectionalLight(0xffffff, 1.2);
  sun.position.set(300, 500, 200);
  scene.add(ambient, sun);

  const axes = new THREE.AxesHelper(100);
  scene.add(axes);

  // ========================= Troika Text 関数 =========================
  const textLabels = [];
  function createTextLabel({text='',pos=[0,0,0],fontSize=1.2,color=0xffffff}) {
    const t = new Text();
    t.text = text;
    t.font = FONT_URL;
    t.fontSize = fontSize;
    t.color = color;
    t.anchorX = 'center';
    t.anchorY = 'bottom';
    t.outlineWidth = 0.03;
    t.outlineColor = 0x000000;
    t.position.set(...pos);
    t.userData = { billboard:true };
    t.sync();
    textLabels.push(t);
    return t;
  }

  // ========================= ピン作成 =========================
  const texCache = new Map();
  const loadTex = url=>{
    if(texCache.has(url))return texCache.get(url);
    const t=new THREE.TextureLoader().load(url);
    texCache.set(url,t);return t;
  };

  function createPin({pos,href,iconBlue,iconRed,scale=3,labelOffset=[0,2,0],labelText=''}) {
    const matBlue=new THREE.SpriteMaterial({map:loadTex(iconBlue),transparent:true});
    const matRed =new THREE.SpriteMaterial({map:loadTex(iconRed),transparent:true});
    const pin=new THREE.Sprite(matBlue);
    pin.position.set(...pos);
    pin.scale.setScalar(scale);
    pin.userData={href,type:'pin',mats:{blue:matBlue,red:matRed}};
    const label=createTextLabel({text:labelText,pos:labelOffset,fontSize:scale*0.8});
    label.visible=false; pin.add(label);
    pin.userData.label=label;
    return pin;
  }

  function createGreenPin({pos,scale=3,labelOffset=[0,2,0],labelText=''}) {
    const mat=new THREE.SpriteMaterial({map:loadTex('./labelpin1green.png'),transparent:true});
    const pin=new THREE.Sprite(mat);
    pin.position.set(...pos);
    pin.scale.setScalar(scale);
    pin.userData={type:'pin',noColorSwap:true};
    const label=createTextLabel({text:labelText,pos:labelOffset,fontSize:scale*0.8});
    label.visible=false; pin.add(label);
    pin.userData.label=label;
    return pin;
  }

  // ========================= エリア =========================
  const areaFxList=[];
  function createHoverArea({center,size,rotYDeg,href,color}) {
    const trigger=new THREE.Mesh(new THREE.BoxGeometry(...size),
      new THREE.MeshBasicMaterial({transparent:true,opacity:0}));
    trigger.position.set(...center);
    trigger.rotation.y=THREE.MathUtils.degToRad(rotYDeg);
    trigger.userData={type:'area',href};
    const fx=new THREE.Mesh(new THREE.BoxGeometry(size[0]*1.02,size[1],size[2]*1.02),
      new THREE.MeshBasicMaterial({color,transparent:true,opacity:0.35,depthWrite:false}));
    fx.position.set(...center);
    fx.rotation.y=THREE.MathUtils.degToRad(rotYDeg);
    fx.visible=false;
    trigger.userData.fx=fx;
    areaFxList.push(fx);
    return {trigger,fx};
  }

  // ========================= GLB 読み込み =========================
  const clickableObjects=[];
  let root=null;
  const gltfLoader=new GLTFLoader();
  gltfLoader.load('./100.glb',g=>{
    root=g.scene;
    scene.add(root);

    // === ピン ===
    const pin1=createPin({
      pos:[10,10,-5],
      href:'https://dazaifu.org/',
      iconBlue:'./pin1blue.png',
      iconRed:'./pin1red.png',
      scale:3,
      labelOffset:[0,2,0],
      labelText:'政庁跡'
    });
    root.add(pin1); clickableObjects.push(pin1);

    const pin2=createPin({
      pos:[20,10,-15],
      href:'https://dazaifu.org/',
      iconBlue:'./pin1blue.png',
      iconRed:'./pin1red.png',
      scale:3,
      labelOffset:[0,2,0],
      labelText:'大宰府跡'
    });
    root.add(pin2); clickableObjects.push(pin2);

    // === 緑ピン ===
    const greens=[
      {pos:[5,11,-8],labelText:'無料駐車場'},
      {pos:[18,12,-12],labelText:'天空カフェ'},
      {pos:[-10,10,14],labelText:'中尊寺'},
      {pos:[30,13,6],labelText:'義経堂'},
      {pos:[-22,11,-4],labelText:'延命地蔵'}
    ];
    greens.forEach(d=>{
      const p=createGreenPin({...d});
      root.add(p); clickableObjects.push(p);
    });

    // === エリア ===
    const defs=[
      {center:[20,7,35],size:[15,1,30],rotYDeg:-14,href:'https://oki-park.jp/shurijo/guide/51',color:0x2a6cff},
      {center:[-16,0,1],size:[15,1,22],rotYDeg:-14,href:'https://example.com/area2',color:0xff7b29},
      {center:[-27,0,22],size:[9,1,18],rotYDeg:-15,href:'https://example.com/area3',color:0x24d18f}
    ];
    defs.forEach(d=>{
      const {trigger,fx}=createHoverArea(d);
      root.add(trigger,fx); clickableObjects.push(trigger);
    });
  });

  // ========================= Hover & Render =========================
  const raycaster=new THREE.Raycaster();
  const mouseNDC=new THREE.Vector2();
  renderer.domElement.addEventListener('pointermove',e=>{
    const r=renderer.domElement.getBoundingClientRect();
    mouseNDC.x=((e.clientX-r.left)/r.width)*2-1;
    mouseNDC.y=-((e.clientY-r.top)/r.height)*2+1;
  });
  let hover=null;

  function animate(){
    requestAnimationFrame(animate);
    raycaster.setFromCamera(mouseNDC,camera);
    const hit=raycaster.intersectObjects(clickableObjects,true)[0]?.object||null;

    if(hover!==hit){
      if(hover?.userData?.type==='pin'){
        if(!hover.userData.noColorSwap)hover.material=hover.userData.mats.blue;
        if(hover.userData.label)hover.userData.label.visible=false;
      }
      hover=hit;
      if(hover?.userData?.type==='pin'){
        if(!hover.userData.noColorSwap)hover.material=hover.userData.mats.red;
        if(hover.userData.label)hover.userData.label.visible=true;
      }
    }

    textLabels.forEach(t=>t.quaternion.copy(camera.quaternion));
    controls.update();
    renderer.render(scene,camera);
  }
  animate();

  window.addEventListener('resize',()=>{
    camera.aspect=container.clientWidth/container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth,container.clientHeight);
  });
</script>
</body>
</html>

