<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>20autorota — three.js viewer (sRGB + Shadow + GUI + Pins)</title>
  <style>
    html,body{height:100%;margin:0}
    #app{position:fixed;inset:0;background:#c2c2c2}
    canvas{display:block}
    .hint{
      position:fixed;left:10px;bottom:10px;color:#cfd8dc;
      font:12px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      opacity:.85;user-select:none;background:rgba(0,0,0,.35);
      padding:6px 8px;border-radius:6px
    }
  </style>

  <script type="importmap">
  { "imports": {
      "three": "https://unpkg.com/three@0.165.0/build/three.module.js"
    } }
  </script>
</head>
<body>
<div id="app"></div>
<div class="hint">左:回転 中:パン ホイール:ズーム｜ピン/エリアはホバーで反応・クリックでリンク（寄ってから即切替）</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'https://unpkg.com/three@0.165.0/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader } from 'https://unpkg.com/three@0.165.0/examples/jsm/loaders/GLTFLoader.js';
import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';

// ========= ① モデル初期値（大きさ・回転・位置） =========
const MODEL_INIT = {
  scale: 1.0,
  rotateDeg: { x: 90, y: 0, z: 0 },
  position:  { x: 0, y: -10, z: 0 }
};

// ========= ② エリア（直方体）定義：ここを書き換える =========
// center: [X,Y,Z] / size: [幅X, 高さY, 奥行Z] / rotYDeg: 水平回転角[deg]
const AREA_DEFS = [
  { center:[3,20,15],  size:[20,3,50], rotYDeg:0, href:'https://oki-park.jp/shurijo/guide/51', color:0x2a6cff, alpha:0.35 },
  { center:[-6,0,0],   size:[4,1,6],   rotYDeg:-14,href:'https://example.com/area-2',          color:0xff7b29, alpha:0.35 },
  { center:[-25,7,15], size:[15,4,20], rotYDeg:-15,href:'https://example.com/area-3',          color:0x24d18f, alpha:0.35 }
];

// ========= ③ 浮上アニメーション設定（動きの速さ・高さ） =========
const fxParams = { height: 8, riseSec: 2.5, fadeSec: 1.2 };

const container = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(container.clientWidth, container.clientHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.shadowMap.enabled = true;
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color('#c2c2c2');

const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 5000);
camera.position.set(0, 40, 80);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.autoRotate = true;
controls.autoRotateSpeed = 0.5;
controls.target.set(0, 0, 0);

const ambient = new THREE.AmbientLight(0xffffff, 0.8);
scene.add(ambient);
const sun = new THREE.DirectionalLight(0xffffff, 1.2);
sun.position.set(3, 5, 2).multiplyScalar(100);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
scene.add(sun);

const ground = new THREE.Mesh(new THREE.PlaneGeometry(4000, 4000), new THREE.ShadowMaterial({ opacity: 0.25 }));
ground.rotation.x = -Math.PI / 2;
ground.position.y = -0.01;
ground.receiveShadow = true;
ground.visible = false;
scene.add(ground);

const axes = new THREE.AxesHelper(100);
scene.add(axes);

// レイキャスト状態
const raycaster = new THREE.Raycaster();
const mouseNDC = new THREE.Vector2();
renderer.domElement.addEventListener('pointermove', (e)=>{
  const r = renderer.domElement.getBoundingClientRect();
  mouseNDC.x = ((e.clientX - r.left) / r.width) * 2 - 1;
  mouseNDC.y = -((e.clientY - r.top) / r.height) * 2 + 1;
});

let root = null;
const clickableObjects = [];
let hoverObject = null;

// テクスチャキャッシュ
const texCache = new Map();
function loadTex(url){
  if (!url) return null;
  if (texCache.has(url)) return texCache.get(url);
  const t = new THREE.TextureLoader().load(url);
  texCache.set(url, t);
  return t;
}

// ピン生成（略）
function createPin({ pos=[0,0,0], href, iconBlue, iconRed, labelPng, scale=10, labelOffset, labelScale=null }) {
  const texBlue  = loadTex(iconBlue);
  const texRed   = loadTex(iconRed);
  const texLabel = labelPng ? loadTex(labelPng) : null;

  const matBlue = new THREE.SpriteMaterial({ map: texBlue, transparent: true });
  const matRed  = new THREE.SpriteMaterial({ map: texRed,  transparent: true });

  const pin = new THREE.Sprite(matBlue);
  pin.position.set(...pos);
  pin.scale.setScalar(scale);
  pin.renderOrder = 10;
  pin.userData = { href, type:'pin', mats:{blue:matBlue, red:matRed}, label:null, noColorSwap:false };

  if (texLabel) {
    const matLabel = new THREE.SpriteMaterial({ map: texLabel, transparent: true, depthTest: true });
    const label = new THREE.Sprite(matLabel);
    label.scale.setScalar(labelScale ?? (scale * 2.0));
    const offset = Array.isArray(labelOffset) ? labelOffset : [0, scale * 1.4, 0];
    label.position.set(...offset);
    label.visible = false;
    pin.add(label);
    pin.userData.label = label;
  }
  return pin;
}

// エリア生成（trigger=root配下、fx=scene配下）
const areaFxList = [];
function createHoverArea({ center, size, rotYDeg, href, color, alpha }) {
  const trigger = new THREE.Mesh(new THREE.BoxGeometry(...size), new THREE.MeshBasicMaterial({ transparent:true, opacity:0.0 }));
  trigger.position.set(...center);
  trigger.rotation.y = THREE.MathUtils.degToRad(rotYDeg);
  trigger.userData = { type:'area', href };

  const fx = new THREE.Mesh(
    new THREE.BoxGeometry(size[0]*1.02, size[1], size[2]*1.02),
    new THREE.MeshBasicMaterial({ color, transparent:true, opacity:alpha, depthWrite:false })
  );
  fx.visible = false;
  fx.userData = { t:0, phase:'idle', alphaBase:alpha, href };

  return { trigger, fx };
}

// モデル読み込み
const gltfLoader = new GLTFLoader();
gltfLoader.load('./100.glb', (gltf) => {
  root = gltf.scene;
  root.traverse(o => { if (o.isMesh){ o.castShadow = true; o.receiveShadow = false; }});
  scene.add(root);

  const box = new THREE.Box3().setFromObject(root);
  const size = new THREE.Vector3(), center = new THREE.Vector3();
  box.getSize(size); box.getCenter(center);
  root.position.sub(center);

  root.scale.setScalar(MODEL_INIT.scale);
  root.rotation.set(
    THREE.MathUtils.degToRad(MODEL_INIT.rotateDeg.x),
    THREE.MathUtils.degToRad(MODEL_INIT.rotateDeg.y),
    THREE.MathUtils.degToRad(MODEL_INIT.rotateDeg.z)
  );
  root.position.add(new THREE.Vector3(MODEL_INIT.position.x, MODEL_INIT.position.y, MODEL_INIT.position.z));

  const maxDim = Math.max(size.x, size.y, size.z);
  const dist = maxDim * 1.6;
  camera.position.set(dist*0.3, dist*0.2, dist*0.3);
  controls.target.set(0,0,0);
  controls.update();

  // ピン例
  const pin1 = createPin({ pos:[10,10,-5], href:'#', iconBlue:'./pin1blue.png', iconRed:'./pin1red.png', labelPng:'./seicho.png', scale:1, labelOffset:[5,3,0] });
  root.add(pin1); clickableObjects.push(pin1);

  // エリア例
  AREA_DEFS.forEach(def=>{
    const { trigger, fx } = createHoverArea(def);
    root.add(trigger);
    scene.add(fx);
    clickableObjects.push(trigger);
    areaFxList.push({ trigger, fx, def });
  });

});

// GUI
const gui = new GUI({ title: 'Controls' });
const params = {
  background:'#c2c2c2',ambientIntensity:ambient.intensity,sunIntensity:sun.intensity,
  sunElevDeg:35,sunAziDeg:25,autoRotate:controls.autoRotate,rotateSpeed:controls.autoRotateSpeed,
  showGroundShadow:ground.visible,showAxes:true,
  rotateX:MODEL_INIT.rotateDeg.x,rotateY:MODEL_INIT.rotateDeg.y,rotateZ:MODEL_INIT.rotateDeg.z
};
gui.addColor(params,'background').name('Background').onChange(v=>scene.background=new THREE.Color(v));

// クリックで寄ってリンク
renderer.domElement.addEventListener('click',()=>{
  if (!hoverObject) return;
  const href = hoverObject.userData.href;
  if (!href) return;
  window.location.href=href;
});

// ループ
const clock=new THREE.Clock();
const worldUp=new THREE.Vector3(0,1,0);
const tmpWorld=new THREE.Vector3();
const tmpQuat=new THREE.Quaternion();
function tick(){
  const dt=clock.getDelta();

  raycaster.setFromCamera(mouseNDC,camera);
  const hits=raycaster.intersectObjects(clickableObjects,true);
  hoverObject=hits.length?hits[0].object.userData.type?hits[0].object:hits[0].object.parent: null;
  renderer.domElement.style.cursor=hoverObject?'pointer':'default';

  // FX同期
  areaFxList.forEach(({trigger,fx,def})=>{
    const active=hoverObject===trigger;
    if(!active){fx.visible=false;fx.userData.phase='idle';fx.userData.t=0;fx.material.opacity=def.alpha;return;}
    trigger.getWorldPosition(tmpWorld);
    trigger.getWorldQuaternion(tmpQuat);
    fx.quaternion.copy(tmpQuat);
    fx.visible=true;
    const p=fx.userData;
    if(p.phase==='idle'){p.phase='rise';p.t=0;fx.position.copy(tmpWorld);fx.material.opacity=def.alpha;}
    else if(p.phase==='rise'){p.t+=dt;const k=Math.min(1,p.t/fxParams.riseSec);fx.position.copy(tmpWorld).addScaledVector(worldUp,fxParams.height*k);fx.material.opacity=def.alpha;if(k>=1){p.phase='fade';p.t=0;}}
    else if(p.phase==='fade'){p.t+=dt;const k=Math.min(1,p.t/fxParams.fadeSec);fx.position.copy(tmpWorld).addScaledVector(worldUp,fxParams.height);fx.material.opacity=def.alpha*(1-k);if(k>=1){p.phase='rise';p.t=0;}}
  });

  if(root){root.rotation.set(THREE.MathUtils.degToRad(params.rotateX),THREE.MathUtils.degToRad(params.rotateY),THREE.MathUtils.degToRad(params.rotateZ));}

  controls.update();
  renderer.render(scene,camera);
  requestAnimationFrame(tick);
}
tick();

window.addEventListener('resize',()=>{
  const w=container.clientWidth,h=container.clientHeight;
  camera.aspect=w/h;
  camera.updateProjectionMatrix();
  renderer.setSize(w,h);
});
</script>
</body>
</html>
