<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>20autorota — three.js viewer (sRGB + Shadow + GUI + Pins)</title>
  <style>
    html,body{height:100%;margin:0}
    #app{position:fixed;inset:0;background:#c2c2c2}
    canvas{display:block}
    .hint{
      position:fixed;left:10px;bottom:10px;color:#cfd8dc;
      font:12px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      opacity:.85;user-select:none;background:rgba(0,0,0,.35);
      padding:6px 8px;border-radius:6px
    }
  </style>

  <script type="importmap">
  { "imports": {
      "three": "https://unpkg.com/three@0.165.0/build/three.module.js"
    } }
  </script>
</head>
<body>
<div id="app"></div>
<div class="hint">左:回転 中:パン ホイール:ズーム｜ピン/エリアはホバーで反応・クリックでリンク（寄ってから即切替）</div>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'https://unpkg.com/three@0.165.0/examples/jsm/controls/OrbitControls.js';
  import { GLTFLoader } from 'https://unpkg.com/three@0.165.0/examples/jsm/loaders/GLTFLoader.js';
  import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';

  // ========================= 基本セットアップ =========================
  const DEFAULT_BG = '#c2c2c2';

  // ★★★★★ モデルの初期値（GUIを使わず固定）★★★★★
  // ここを書き換えるだけで「モデルの大きさ・回転[deg]・位置」を決め打ちできます
  const MODEL_INIT = {
    scale: 1.0,                         // モデル全体スケール
    rotateDeg: { x: 90, y: 0, z: 0 },   // 回転角[度]（X/Y/Z）
    position:  { x: 0,  y: -10, z: 0 }  // 位置（X/Y/Z）
  };

  // ★★★★★ エリア（半透明直方体）を編集する場所 ★★★★★
  // 直方体の「縦・横・高さ」「中心位置」「Y回転角（度）」をここで指定。
  // color: 直方体の色、alpha: 不透明度。
  // ※ ワールドの +Y 方向（黄色の上）に浮きます。モデルを何度回転してもズレません。
  const AREA_DEFS = [
    {
      // 直方体の中心位置（X,Y,Z）— モデル空間での位置（トリガー基準）
      center: [  3, 20, 15 ],
      // 直方体サイズ [幅X, 高さY, 奥行Z]
      size:   [  50, 50, 50 ],
      // Y軸回転角（度）— 平面内の向き。0でモデルのX/Z軸に沿う
      rotYDeg: 10,
      // クリック先URL（不要なら null）
      href: 'https://oki-park.jp/shurijo/guide/51',
      // 表示色＆透明度
      color: 0x2a6cff,
      alpha: 0.35
    },
    {
      center: [ -6, 0, 0 ],
      size:   [  4, 1, 6 ],
      rotYDeg: -14,
      href: 'https://example.com/area-2',
      color: 0xff7b29,
      alpha: 0.35
    },
    {
      center: [ -25, 7, 15 ],
      size:   [  15, 4, 20 ],
      rotYDeg: -15,
      href: 'https://example.com/area-3',
      color: 0x24d18f,
      alpha: 0.35
    }
  ];

  // 浮上アニメのパラメータ（動きは今のまま維持）
  const fxParams = {
    height: 8,     // どれだけ上に浮くか（ワールドY方向の距離）
    riseSec: 2.5,  // 上昇にかける秒数
    fadeSec: 1.2   // フェードアウトにかける秒数
  };

  const container = document.getElementById('app');

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.shadowMap.enabled = true;
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(DEFAULT_BG);

  const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 5000);
  camera.position.set(0, 40, 80);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.autoRotate = true;
  controls.autoRotateSpeed = 0.5;
  controls.target.set(0, 0, 0);

  // ライティング
  const ambient = new THREE.AmbientLight(0xffffff, 0.8);
  scene.add(ambient);
  const sun = new THREE.DirectionalLight(0xffffff, 1.2);
  sun.position.set(3, 5, 2).multiplyScalar(100);
  sun.castShadow = true;
  sun.shadow.mapSize.set(2048, 2048);
  sun.shadow.camera.near = 10;
  sun.shadow.camera.far = 1000;
  sun.shadow.camera.left = -300;
  sun.shadow.camera.right = 300;
  sun.shadow.camera.top = 300;
  sun.shadow.camera.bottom = -300;
  scene.add(sun);

  const ground = new THREE.Mesh(new THREE.PlaneGeometry(4000, 4000), new THREE.ShadowMaterial({ opacity: 0.25 }));
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -0.01;
  ground.receiveShadow = true;
  ground.visible = false;
  scene.add(ground);

  const axes = new THREE.AxesHelper(100);
  scene.add(axes);

  // ========================= Raycaster & 状態 =========================
  const raycaster = new THREE.Raycaster();
  const mouseNDC = new THREE.Vector2();

  renderer.domElement.addEventListener('pointermove', (e)=>{
    const r = renderer.domElement.getBoundingClientRect();
    mouseNDC.x = ((e.clientX - r.left) / r.width) * 2 - 1;
    mouseNDC.y = -((e.clientY - r.top) / r.height) * 2 + 1;
  });

  let root = null;
  const clickableObjects = []; // ピン・エリアtrigger（レイキャスト対象）
  let hoverObject = null;

  // ========================= テクスチャキャッシュ =========================
  const texCache = new Map();
  function loadTex(url){
    if (!url) return null;
    if (texCache.has(url)) return texCache.get(url);
    const t = new THREE.TextureLoader().load(url);
    texCache.set(url, t);
    return t;
  }

  // ========================= カメラ飛行ユーティリティ =========================
  let _flying = false;
  function flyTo(camera, controls, destPos, destLook, duration = 1600, onDone){
    if (_flying) return;
    _flying = true;

    const startPos  = camera.position.clone();
    const startLook = controls.target.clone();
    const easeInOutCubic = (t)=> t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
    const t0 = performance.now();

    const prevEnabled = controls.enabled;
    const prevAutoRotate = controls.autoRotate;
    controls.enabled = false;
    controls.autoRotate = false;

    function step(now){
      const t = Math.min(1, (now - t0) / duration);
      const k = easeInOutCubic(t);

      camera.position.lerpVectors(startPos, destPos, k);
      controls.target.lerpVectors(startLook, destLook, k);
      camera.lookAt(controls.target);

      if (t < 1){
        requestAnimationFrame(step);
      } else {
        controls.enabled = prevEnabled;
        controls.autoRotate = prevAutoRotate;
        _flying = false;
        onDone && onDone();
      }
    }
    requestAnimationFrame(step);
  }

  // ========================= ピン関係（そのまま） =========================
  function createPin({ pos=[0,0,0], href, iconBlue, iconRed, labelPng, scale=10, labelOffset, labelScale=null }) {
    const texBlue  = loadTex(iconBlue);
    const texRed   = loadTex(iconRed);
    const texLabel = labelPng ? loadTex(labelPng) : null;

    const matBlue = new THREE.SpriteMaterial({ map: texBlue, transparent: true });
    const matRed  = new THREE.SpriteMaterial({ map: texRed,  transparent: true });

    const pin = new THREE.Sprite(matBlue);
    pin.position.set(...pos);
    pin.scale.setScalar(scale);
    pin.renderOrder = 10;
    pin.userData = { href, type:'pin', mats:{blue:matBlue, red:matRed}, label:null, noColorSwap:false };

    if (texLabel) {
      const matLabel = new THREE.SpriteMaterial({ map: texLabel, transparent: true, depthTest: true });
      const label = new THREE.Sprite(matLabel);
      label.scale.setScalar(labelScale ?? (scale * 2.0));
      const offset = Array.isArray(labelOffset) ? labelOffset : [0, scale * 1.4, 0];
      label.position.set(...offset);
      label.visible = false;
      pin.add(label);
      pin.userData.label = label;
    }
    return pin;
  }

  function createGreenPin({ pos=[0,0,0], labelPng, scale=1, labelOffset=[0, scale*1.4, 0], labelScale=null }) {
    const texPin   = loadTex('./labelpin1green.png');
    const texLabel = loadTex(labelPng);

    const matPin = new THREE.SpriteMaterial({ map: texPin, transparent: true });
    const pin = new THREE.Sprite(matPin);
    pin.position.set(...pos);
    pin.scale.setScalar(scale);
    pin.renderOrder = 10;
    pin.userData = { type:'pin', mats:{blue:matPin, red:matPin}, label:null, noColorSwap:true, href:null };

    const matLabel = new THREE.SpriteMaterial({ map: texLabel, transparent: true, depthTest: true });
    const label = new THREE.Sprite(matLabel);
    label.scale.setScalar(labelScale ?? (scale * 2.0));
    label.position.set(...labelOffset);
    label.visible = false;
    pin.add(label);
    pin.userData.label = label;
    return pin;
  }

  // ========================= エリア（トリガー＆FXボックス） =========================
  // 重要：トリガー（レイキャスト用）は root 配下、FXボックスは scene 直下に置く。
  // こうすることで、root を90°回しても、FXはワールド+Yに正しく浮く。
  const areaFxList = []; // { trigger, fx, baseWorldY, state... } の配列

  function createHoverArea({ center, size, rotYDeg, href, color, alpha }) {
    // トリガー（不可視）：root 配下（モデル空間）
    const trigger = new THREE.Mesh(
      new THREE.BoxGeometry(size[0], size[1], size[2]),
      new THREE.MeshBasicMaterial({ transparent:true, opacity:0.0 })
    );
    trigger.position.set(center[0], center[1], center[2]);
    trigger.rotation.y = THREE.MathUtils.degToRad(rotYDeg);
    trigger.userData = { type:'area', href };

    // FXボックス（半透明可視）：scene 直下（ワールド空間）
    const fx = new THREE.Mesh(
      new THREE.BoxGeometry(size[0]*1.02, size[1], size[2]*1.02),
      new THREE.MeshBasicMaterial({ color, transparent:true, opacity:alpha, depthWrite:false })
    );
    fx.visible = false;
    fx.userData = {
      t: 0, phase: 'idle',
      alphaBase: alpha,
      href
    };

    // 角度はトリガーのY回転に合わせたいので、毎フレーム world の回転を同期する
    // （→ tick() で trigger の worldQuaternion を fx にコピーします）

    return { trigger, fx };
  }

  // ========================= モデル読込 =========================
  const gltfLoader = new GLTFLoader();
  gltfLoader.load('./100.glb', (gltf) => {
    root = gltf.scene;
    root.traverse(o => { if (o.isMesh){ o.castShadow = true; o.receiveShadow = false; }});
    scene.add(root);

    // モデル原点合わせ
    const box = new THREE.Box3().setFromObject(root);
    const size = new THREE.Vector3(), center = new THREE.Vector3();
    box.getSize(size); box.getCenter(center);
    root.position.sub(center);

    // モデル初期値適用
    root.scale.setScalar(MODEL_INIT.scale);
    root.rotation.set(
      THREE.MathUtils.degToRad(MODEL_INIT.rotateDeg.x),
      THREE.MathUtils.degToRad(MODEL_INIT.rotateDeg.y),
      THREE.MathUtils.degToRad(MODEL_INIT.rotateDeg.z)
    );
    root.position.add(new THREE.Vector3(MODEL_INIT.position.x, MODEL_INIT.position.y, MODEL_INIT.position.z));

    // カメラ初期配置
    const maxDim = Math.max(size.x, size.y, size.z);
    const dist = maxDim * 1.6;
    camera.position.set(dist*0.3, dist*0.2, dist*0.3);
    controls.target.set(0,0,0);
    controls.update();

    // ピン（例）
    const pin1 = createPin({
      pos: [10, 10, -5],
      href: 'https://dazaifu.org/dazaifu-seicho-ato/',
      iconBlue: './pin1blue.png',
      iconRed:  './pin1red.png',
      labelPng: './seicho.png',
      scale: 1,
      labelOffset: [5, 3, 0],
    });
    root.add(pin1); clickableObjects.push(pin1);

    const pin2 = createPin({
      pos: [20, 10, -15],
      href: 'https://dazaifu.org/dazaifu-seicho-ato/',
      iconBlue: './pin1blue.png',
      iconRed:  './pin1red.png',
      labelPng: './seicho.png',
      scale: 1,
      labelOffset: [5, 3, 0],
    });
    root.add(pin2); clickableObjects.push(pin2);

    // 緑ピン（例）
    [
      { pos:[  5, 11,  -8], label:'./muryou.png' },
      { pos:[ 18, 12, -12], label:'./tenku.png' },
      { pos:[-10, 10,  14], label:'./tyuson.png' },
      { pos:[ 30, 13,   6], label:'./yoshi.png' },
      { pos:[-22, 11,  -4], label:'./enmei.png' },
    ].forEach(({pos, label})=>{
      const p = createGreenPin({ pos, labelPng: label, scale: 1, labelOffset:[0,1.5,0], labelScale: 1.0 });
      root.add(p); clickableObjects.push(p);
    });

    // エリア生成：trigger は root に、fx は scene に追加
    AREA_DEFS.forEach(def=>{
      const { trigger, fx } = createHoverArea(def);
      root.add(trigger);              // ← モデル空間
      scene.add(fx);                  // ← ワールド空間（上方向が常に +Y）
      clickableObjects.push(trigger);
      areaFxList.push({ trigger, fx, def }); // 後で同期に使う
    });

  }, undefined, (err)=>{
    console.error(err);
    alert('GLBの読み込みに失敗しました。パス/ファイル名をご確認ください。');
  });

  // ========================= GUI（最低限） =========================
  const gui = new GUI({ title: 'Controls' });
  const params = {
    background: DEFAULT_BG,
    ambientIntensity: ambient.intensity,
    sunIntensity: sun.intensity,
    sunElevDeg: 35,
    sunAziDeg: 25,
    autoRotate: controls.autoRotate,
    rotateSpeed: controls.autoRotateSpeed,
    showGroundShadow: ground.visible,
    showAxes: true,
    rotateX: MODEL_INIT.rotateDeg.x,
    rotateY: MODEL_INIT.rotateDeg.y,
    rotateZ: MODEL_INIT.rotateDeg.z
  };
  const upSun = ()=>{
    const elev = THREE.MathUtils.degToRad(params.sunElevDeg);
    const azi  = THREE.MathUtils.degToRad(params.sunAziDeg);
    const r = 100;
    sun.position.set(r*Math.cos(elev)*Math.cos(azi), r*Math.sin(elev), r*Math.cos(elev)*Math.sin(azi));
  };
  upSun();

  gui.addColor(params, 'background').name('Background').onChange(v=> scene.background = new THREE.Color(v));
  const fL = gui.addFolder('Lighting');
  fL.add(params, 'ambientIntensity', 0, 2.5, 0.01).name('Ambient').onChange(v=> ambient.intensity = v);
  fL.add(params, 'sunIntensity', 0, 3, 0.01).name('Sun').onChange(v=> sun.intensity = v);
  fL.add(params, 'sunElevDeg', 0, 90, 1).name('Sun Elev [deg]').onChange(upSun);
  fL.add(params, 'sunAziDeg', -180, 180, 1).name('Sun Azi [deg]').onChange(upSun);
  fL.add(params, 'showGroundShadow').name('Ground shadow').onChange(v=> ground.visible = v);
  const fM = gui.addFolder('Model Rotation');
  fM.add(params, 'rotateX', -180, 180, 1).name('Rotate X [deg]');
  fM.add(params, 'rotateY', -180, 180, 1).name('Rotate Y [deg]');
  fM.add(params, 'rotateZ', -180, 180, 1).name('Rotate Z [deg]');
  const fV = gui.addFolder('View');
  fV.add(params, 'autoRotate').name('Auto rotate').onChange(v=> controls.autoRotate = v);
  fV.add(params, 'rotateSpeed', -3, 3, 0.1).name('Rotate speed').onChange(v=> controls.autoRotateSpeed = v);
  gui.add(params, 'showAxes').name('Show axes').onChange(v=> axes.visible = v);

  // ========================= クリック（寄ってから遷移） =========================
  const _p = new THREE.Vector3();
  const _box = new THREE.Box3();
  const _size = new THREE.Vector3();

  renderer.domElement.addEventListener('click', ()=>{
    if (!hoverObject || _flying) return;
    const ud = hoverObject.userData || {};
    const href = ud.href;
    if (!href) return;

    hoverObject.getWorldPosition(_p);
    const p = _p.clone();

    const d0 = camera.position.distanceTo(p);
    let desiredDist;
    if (hoverObject.isMesh) {
      _box.setFromObject(hoverObject);
      _box.getSize(_size);
      const r = Math.max(_size.x, _size.y, _size.z) * 0.5;
      desiredDist = THREE.MathUtils.clamp(r * 2.2, 10, 120);
    } else {
      desiredDist = THREE.MathUtils.clamp(d0 * 0.35, 10, 120);
    }

    const dir = camera.position.clone().sub(p).normalize();
    const autoCam = p.clone().add(dir.multiplyScalar(desiredDist));

    const destPos = autoCam;
    const lookAt  = p.clone();
    const duration = 1500;

    flyTo(camera, controls, destPos, lookAt, duration, ()=>{
      window.location.href = href;
    });
  });

  // ========================= ループ =========================
  const clock = new THREE.Clock();
  const easeOutCubic = x => 1 - Math.pow(1 - x, 3);
  const easeInQuad   = x => x * x;
  const worldUp = new THREE.Vector3(0,1,0);
  const tmpWorld = new THREE.Vector3();
  const tmpQuat  = new THREE.Quaternion();

  function tick(){
    const dt = clock.getDelta();

    // レイキャスト
    raycaster.setFromCamera(mouseNDC, camera);
    const hits = raycaster.intersectObjects(clickableObjects, true);
    let hit = null;
    if (hits.length){
      const obj = hits[0].object;
      hit = (obj.userData?.type) ? obj
           : (obj.parent?.userData?.type) ? obj.parent
           : obj;
    }

    // ホバー切替（ピン：色/ラベル）
    if (hoverObject !== hit) {
      if (hoverObject && hoverObject.userData.type === 'pin') {
        if (!hoverObject.userData.noColorSwap) {
          hoverObject.material = hoverObject.userData.mats.blue;
        }
        if (hoverObject.userData.label) hoverObject.userData.label.visible = false;
      }
      hoverObject = hit;
      if (hoverObject && hoverObject.userData.type === 'pin') {
        if (!hoverObject.userData.noColorSwap) {
          hoverObject.material = hoverObject.userData.mats.red;
        }
        if (hoverObject.userData.label) hoverObject.userData.label.visible = true;
      }
      renderer.domElement.style.cursor = hoverObject ? 'pointer' : 'default';
    }

    // ★★★ エリアFX（ワールド+Yに必ず浮く） ★★★
    areaFxList.forEach(({ trigger, fx, def })=>{
      // トリガーがホバー中か？
      const active = (hoverObject && hoverObject === trigger);
      if (!active) {
        fx.visible = false;
        fx.userData.phase = 'idle';
        fx.userData.t = 0;
        fx.material.opacity = def.alpha;
        return;
      }

      fx.visible = true;

      // トリガーのワールド位置・回転を取得して、FXに同期（向きも揃える）
      trigger.getWorldPosition(tmpWorld);
      trigger.getWorldQuaternion(tmpQuat);
      fx.quaternion.copy(tmpQuat); // Y回転（水平向き）を一致させる

      // 位相更新
      const p = fx.userData;
      if (p.phase === 'idle') {
        p.phase = 'rise'; p.t = 0;
        fx.position.copy(tmpWorld);
        fx.material.opacity = def.alpha;
      } else if (p.phase === 'rise') {
        p.t += dt;
        const k = Math.min(1, p.t / fxParams.riseSec);
        // ここが肝：ワールドの +Y 方向にのみオフセット
        fx.position.copy(tmpWorld).addScaledVector(worldUp, fxParams.height * easeOutCubic(k));
        fx.material.opacity = def.alpha;
        if (k >= 1) { p.phase = 'fade'; p.t = 0; }
      } else if (p.phase === 'fade') {
        p.t += dt;
        const k = Math.min(1, p.t / fxParams.fadeSec);
        fx.position.copy(tmpWorld).addScaledVector(worldUp, fxParams.height); // 最高点のまま
        fx.material.opacity = def.alpha * (1 - easeInQuad(k));
        if (k >= 1) { p.phase = 'rise'; p.t = 0; }
      }
    });

    // モデル回転（GUIと同期）
    if (root){
      root.rotation.set(
        THREE.MathUtils.degToRad(params.rotateX),
        THREE.MathUtils.degToRad(params.rotateY),
        THREE.MathUtils.degToRad(params.rotateZ)
      );
    }

    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(tick);
  }
  tick();

  // リサイズ
  window.addEventListener('resize', ()=>{
    const w = container.clientWidth, h = container.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  });
</script>
</body>
</html>
